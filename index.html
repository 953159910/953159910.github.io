<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>The Backrooms V22.13 - Roll Group 最终稳定版</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; color: white; background-color: #000; }
        #instructions {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; color: white; background: rgba(0,0,0,0.5);
            padding: 20px; border: 1px solid #fff; cursor: pointer;
            z-index: 10; user-select: none;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; background: white; z-index: 1;
        }
        #status-bar {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            width: 300px;
        }
        #hud {
            position: absolute; top: 110px; left: 10px; z-index: 20; 
            width: 300px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px;
            border-radius: 3px;
            display: none; 
        }
        .bar-container {
            margin-bottom: 5px; background: rgba(0, 0, 0, 0.5); border: 1px solid #fff;
            height: 20px; position: relative;
        }
        .bar-fill {
            height: 100%; transition: width 0.1s linear;
        }
        #health-bar .bar-fill { background: red; }
        #stamina-bar .bar-fill { background: green; }
        #message {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1); color: yellow; padding: 5px 10px;
            border-radius: 5px; opacity: 0; transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    
    <audio id="the-hum" loop></audio>
    <audio id="almond-pickup"></audio>
    <audio id="monster-chase" loop></audio>
</head>
<body>
    <div id="instructions">
        <h1>THE BACKROOMS LEVEL 0 (V22.13 Roll Group 最终稳定版)</h1>
        <p>通过 Roll Group 结构重构，彻底解决旋转卡死和翻转问题。</p>
        <p>W, A, S, D 移动 | **SPACE 跳跃** | SHIFT 奔跑 | **E 开启/关闭 调试信息**</p>
        <p>点击屏幕开始</p>
    </div>
    <div id="crosshair"></div>
    
    <div id="status-bar">
        HP: <div id="health-bar" class="bar-container"><div class="bar-fill" style="width: 100%;"></div></div>
        Stamina: <div id="stamina-bar" class="bar-container"><div class="bar-fill" style="width: 100%;"></div></div>
    </div>

    <div id="hud"> 
        <p>Debug Info (E):</p>
        <p>当前 Level: <span id="current-level-text">0</span></p>
        <p>帧数 (FPS): <span id="fps-text">N/A</span></p>
        <p>实体距离: <span id="distance-text">N/A</span></p>
        <p>杏仁水存量: <span id="almond-count-text">N/A</span></p>
        <p>最近杏仁水距离: <span id="nearest-almond-distance-text">N/A</span></p>
        <p>出口门距离: <span id="exit-door-distance-text">N/A</span></p>
    </div>
    <div id="message"></div>

    <script>
        // --- 1. 全局变量声明 ---
        
        let GRID_SIZE = 30; 
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 3;
        const PLAYER_HEIGHT = 1.6;
        let MAP_WORLD_SIZE = GRID_SIZE * TILE_SIZE; 
        let HALF_MAP_SIZE = MAP_WORLD_SIZE / 2;
        let currentLevel = 0; 

        const WALK_ACCEL = 50.0;
        const RUN_ACCEL = 100.0; 
        const JUMP_VELOCITY = 6.0; 
        const GRAVITY = -15.0; 
        const PLAYER_WIDTH = 1.0; 
        const PLAYER_DEPTH = 1.0;

        // 视角倾斜参数
        let rotationTargetZ = 0; 
        let prevCameraRotationY; 
        const SWAY_MAX_ANGLE = Math.PI * 0.05; 
        const SWAY_SMOOTHING = 0.2; 
        const MAX_PITCH_RADIANS = 1.48; // 约 85 度
        const TWO_PI = Math.PI * 2; 
        
        // V22.13 新增：用于隔离Z轴旋转的组
        let rollGroup; 

        let health = 100;
        let stamina = 100;
        const STAMINA_RUN_COST = 20; 
        const STAMINA_REGEN = 15;
        const MONSTER_DAMAGE = 20;

        let camera, scene, renderer, controls;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let wallBoundingBoxes = []; 
        let playerBox = new THREE.Box3(); 
        let wallObjects = []; 
        let almondWaterObjects = []; 
        let monster;
        let exitDoor; 
        let monsterState = 'wandering'; 
        let monsterWanderTarget = new THREE.Vector3();
        let monsterDistance = Infinity;
        
        const MONSTER_SPEED = 3.0; 
        const CHASE_DISTANCE = 15; 
        const MONSTER_COLLISION_DISTANCE = 0.5;
        
        const TELEPORT_COOLDOWN = 60000; 
        const TELEPORT_CHECK_INTERVAL = 10000; 
        let lastTeleportTime = 0;
        let lastTeleportCheckTime = 0;
        let totalDistanceTraveled = 0;
        const ALMOND_SPAWN_INTERVAL = 100; 
        let distanceToNextSpawn = ALMOND_SPAWN_INTERVAL;
        // V22.13: 跟踪位置改为跟踪 Roll Group的位置
        let lastCameraPosition = new THREE.Vector3(); 

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isShiftDown = false;
        let canJump = false;
        let noClip = false;
        let currentFPS = 0;
        let debugHudVisible = false; 
        let MAP_DATA;

        // --- 2. 核心函数定义 ---

        window.onload = function() {
            try {
                document.getElementById('the-hum').src = 'the_hum.mp3';
                document.getElementById('almond-pickup').src = 'almond_pickup.mp3';
                document.getElementById('monster-chase').src = 'monster_chase.mp3';
            } catch(e) { console.log("Audio setup skipped"); }

            init();
            animate();
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- V22.13 结构重构 START：隔离Z轴旋转 ---
            rollGroup = new THREE.Group();
            rollGroup.add(camera);      // 将摄像机加入到 Roll Group
            scene.add(rollGroup);       // 将 Roll Group 加入到场景

            // 摄像机本身不再需要定位，它在 Roll Group 的中心
            camera.position.set(0, 0, 0); 
            
            // Controls 附加到 Roll Group，Roll Group 现在代表玩家的 "身体"
            controls = new THREE.PointerLockControls(rollGroup, document.body); 
            // --- V22.13 结构重构 END ---

            setupInputs();
            window.addEventListener('resize', onWindowResize);
            
            setupLevel(0); 
            if(typeof updateHUD === 'function') updateHUD();
        }

        function setupLevel(levelIndex) {
            // ... (setupLevel 函数的大部分保持不变) ...
            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            wallObjects.length = 0; 
            wallBoundingBoxes.length = 0;
            almondWaterObjects.length = 0; 
            
            currentLevel = levelIndex;
            
            let floorColor, wallColor, fogColor, levelSize, wallDensity;

            if (levelIndex === 0) {
                levelSize = 30;
                wallColor = 0xb6a04e;
                floorColor = 0x91815f;
                fogColor = 0x998b4b;
                wallDensity = 0.35;
            } else if (levelIndex === 1) {
                levelSize = 25; 
                wallColor = 0x808000; 
                floorColor = 0x444444; 
                fogColor = 0x333333; 
                wallDensity = 0.20; 
            } else {
                return; 
            }

            GRID_SIZE = levelSize;
            MAP_WORLD_SIZE = GRID_SIZE * TILE_SIZE; 
            HALF_MAP_SIZE = MAP_WORLD_SIZE / 2;

            scene.background = new THREE.Color(fogColor); 
            scene.fog = new THREE.FogExp2(fogColor, 0.08); 

            MAP_DATA = generateRandomMap(levelSize, wallDensity); 
            const wallTexture = createNoiseTexture(wallColor); 
            const floorTexture = createNoiseTexture(floorColor); 
            const ceilingTexture = createNoiseTexture(0xaaaaaa); 
            createMaze(wallTexture, floorTexture, ceilingTexture);
            
            const halfFinalSize = HALF_MAP_SIZE;
            
            // V22.13: 设置 rollGroup 的起始位置
            rollGroup.position.x = TILE_SIZE * 1.5 - halfFinalSize; 
            rollGroup.position.z = TILE_SIZE * 1.5 - halfFinalSize;
            rollGroup.position.y = PLAYER_HEIGHT;
            lastCameraPosition.copy(rollGroup.position);


            if (levelIndex === 0) {
                createExitDoor(); 
            } else if (levelIndex === 1) {
                addLevel1Details(levelSize); 
            }
            
            createMonster();
            spawnAlmondWater(3 + levelIndex * 2); 

            health = 100;
            stamina = 100;
            lastTeleportTime = performance.now();
            lastTeleportCheckTime = performance.now();
            totalDistanceTraveled = 0;
            distanceToNextSpawn = ALMOND_SPAWN_INTERVAL;
            updateHUD();
        }

        // ... (addLevel1Details, createExitTextTexture, createExitDoor, checkCollision, createMonster, monsterAI, 等辅助函数保持不变) ...

        function onMouseDown(event) {
            if (controls.isLocked && event.button === 0) { 
                const pickupRaycaster = new THREE.Raycaster();
                // 射线投射仍基于 camera
                pickupRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
                
                const almondIntersects = pickupRaycaster.intersectObjects(almondWaterObjects);
                if (almondIntersects.length > 0 && almondIntersects[0].distance < 2.0) { 
                    const bottle = almondIntersects[0].object;
                    health = 100; stamina = 100; updateHUD();
                    showPickupMessage("杏仁水：生命值和体力已恢复！");
                    document.getElementById('almond-pickup').play().catch(e=>{});
                    scene.remove(bottle);
                    const index = almondWaterObjects.indexOf(bottle);
                    if (index > -1) almondWaterObjects.splice(index, 1);
                    return;
                }
                
                if (currentLevel === 0 && exitDoor) {
                    const exitIntersects = pickupRaycaster.intersectObjects([exitDoor]);
                    if (exitIntersects.length > 0 && exitIntersects[0].distance < 3.0) {
                        showPickupMessage("找到出口! 正在进入 Level 1: 宜居区...");
                        setTimeout(() => setupLevel(1), 2000); 
                    }
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const timeMs = time; 
            const delta = (time - prevTime) / 1000;
            currentFPS = 1 / delta;
            
            if (controls.isLocked === true && health > 0) {
                
                // V22.13 FIX: 钳制 rollGroup 的 X 轴旋转
                rollGroup.rotation.x = Math.max(-MAX_PITCH_RADIANS, Math.min(MAX_PITCH_RADIANS, rollGroup.rotation.x));

                // V22.13 FIX: 跟踪 rollGroup 的位置
                const distanceMoved = rollGroup.position.distanceTo(lastCameraPosition);
                totalDistanceTraveled += distanceMoved;
                lastCameraPosition.copy(rollGroup.position);

                // ... (怪物 AI 传送检查逻辑不变) ...
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y += GRAVITY * delta; 
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                
                let currentAccel = WALK_ACCEL;
                if ((moveForward || moveBackward || moveLeft || moveRight) && isShiftDown && stamina > 0) {
                    currentAccel = RUN_ACCEL;
                    stamina -= STAMINA_RUN_COST * delta; 
                } else if (stamina < 100) {
                    stamina += STAMINA_REGEN * delta;
                }
                stamina = Math.min(100, Math.max(0, stamina));
                if (stamina <= 0) { currentAccel = WALK_ACCEL; isShiftDown = false; }

                if (moveForward || moveBackward) velocity.z -= direction.z * currentAccel * delta; 
                if (moveLeft || moveRight) velocity.x -= direction.x * currentAccel * delta;

                const localStepX = -velocity.x * delta;
                const localStepZ = -velocity.z * delta;

                // 碰撞和移动逻辑 (目标对象仍然是 controls 所控制的 rollGroup)
                if (!noClip) {
                    if (Math.abs(localStepX) > 0) {
                        controls.moveRight(localStepX);
                        // V22.13 FIX: 碰撞检测基于 rollGroup 的位置
                        playerBox.setFromCenterAndSize(rollGroup.position, new THREE.Vector3(PLAYER_WIDTH, 2, PLAYER_DEPTH));
                        if (checkCollision(playerBox)) {
                            controls.moveRight(-localStepX); 
                            velocity.x = 0;
                        }
                    }
                    if (Math.abs(localStepZ) > 0) {
                        controls.moveForward(localStepZ);
                        // V22.13 FIX: 碰撞检测基于 rollGroup 的位置
                        playerBox.setFromCenterAndSize(rollGroup.position, new THREE.Vector3(PLAYER_WIDTH, 2, PLAYER_DEPTH));
                        if (checkCollision(playerBox)) {
                            controls.moveForward(-localStepZ); 
                            velocity.z = 0;
                        }
                    }
                } else {
                    controls.moveRight(localStepX); 
                    controls.moveForward(localStepZ); 
                }
                
                // V22.13 FIX: 应用重力和跳跃到 rollGroup 的 Y 轴位置
                rollGroup.position.y += velocity.y * delta;
                if (rollGroup.position.y <= PLAYER_HEIGHT) {
                    velocity.y = 0;
                    rollGroup.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }
                
                // --- 视角倾斜/旋转逻辑 (V22.13 Roll Group 稳定版) ---
                if (prevCameraRotationY !== undefined) {
                    // V22.13 FIX: 使用 rollGroup.rotation.y 计算 Delta
                    let deltaY = rollGroup.rotation.y - prevCameraRotationY; 
                    
                    // 修正 Delta 环绕，防止 180度翻转
                    if (Math.abs(deltaY) > Math.PI) {
                        deltaY -= Math.sign(deltaY) * TWO_PI;
                    }

                    rotationTargetZ = THREE.MathUtils.clamp(
                        deltaY * 10 * SWAY_MAX_ANGLE, 
                        -SWAY_MAX_ANGLE, SWAY_MAX_ANGLE 
                    );
                }
                
                // V22.13 FIX: 平滑应用倾斜到 rollGroup 的 Z 轴
                rollGroup.rotation.z += (rotationTargetZ - rollGroup.rotation.z) * SWAY_SMOOTHING;
                
                // 跟踪 rollGroup 的原始累积值
                prevCameraRotationY = rollGroup.rotation.y;

                // --- 视角倾斜/旋转逻辑 结束 ---

                monsterAI(delta); 
                updateHUD();
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
        
        // ... (其余辅助函数保持不变) ...
        
        function updateHUD() {
            // ... (更新 HUD 的逻辑保持不变，但所有涉及 camera.position 的距离计算需要改为 rollGroup.position) ...
            if (!document.getElementById('health-bar')) return;
            document.getElementById('health-bar').children[0].style.width = `${Math.max(0, health)}%`;
            document.getElementById('stamina-bar').children[0].style.width = `${Math.max(0, stamina)}%`;
            
            let nearestDistance = Infinity;
            almondWaterObjects.forEach(bottle => {
                // V22.13 FIX: 使用 rollGroup.position
                const dist = rollGroup.position.distanceTo(bottle.position);
                if (dist < nearestDistance) nearestDistance = dist;
            });

            let exitDistance = Infinity;
            if (exitDoor && currentLevel === 0) {
                // V22.13 FIX: 使用 rollGroup.position
                exitDistance = rollGroup.position.distanceTo(exitDoor.position);
            }
            
            document.getElementById('hud').style.display = debugHudVisible ? 'block' : 'none'; 
            
            // ... (游戏结束检查及 debug info 保持不变) ...

            if (debugHudVisible) {
                // ... (其他 debug info 保持不变) ...
                document.getElementById('distance-text').textContent = monsterDistance === Infinity ? 'N/A' : `${monsterDistance.toFixed(2)} m`;
                document.getElementById('almond-count-text').textContent = almondWaterObjects.length;
                document.getElementById('nearest-almond-distance-text').textContent = nearestDistance === Infinity ? 'N/A' : `${nearestDistance.toFixed(2)} m`;
                document.getElementById('exit-door-distance-text').textContent = exitDistance === Infinity ? 'N/A' : `${exitDistance.toFixed(2)} m`;
            }
        }

        // ... (其他函数保持不变) ...

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
